#include "clang/AST/AST.h"  // AST.h: Defines the Abstract Syntax Tree (AST) core data structures.
//  - An AST is a tree-based representation of source code where each node represents a language construct (e.g., an expression, statement, declaration).
//  - The AST is generated by clang parsing C/C++ code and is used for analysis and transformations.

#include "clang/AST/RecursiveASTVisitor.h"  // RecursiveASTVisitor: A template base class to traverse AST nodes.
//  - Provides TraverseXXX and VisitXXX hooks. "Visit" methods are called for nodes of a specific type.
//  - We inherit from this to walk through all statements and expressions in a function body.

#include "clang/ASTMatchers/ASTMatchers.h"  // ASTMatchers DSL: Allows pattern-matching on AST nodes.
//  - E.g., matching function calls, declarations, types without manual tree traversal.
//  - Facilitates finding `system()` calls via a declarative API.

#include "clang/ASTMatchers/ASTMatchFinder.h"  // ASTMatchFinder: Registers matchers and callbacks.
//  - Takes matcher definitions (patterns) and invokes our callback when matches occur.

#include "clang/Frontend/FrontendActions.h"  // FrontendAction: Defines actions at start/end of parsing a translation unit.
//  - We implement ASTFrontendAction to set up matchers before clang parses files.

#include "clang/Rewrite/Core/Rewriter.h"  // Rewriter: Utility to perform source-to-source transformations.
//  - Tracks edits and can output modified source. We include but don’t rewrite in this tool.

#include "clang/Tooling/Tooling.h"  // Common tooling classes (ClangTool, CommonOptionsParser).
//  - Provides ClangTool for running actions over multiple files via a compilation database.

#include "clang/Frontend/CompilerInstance.h"  // CompilerInstance: Holds per-file compiler state, ASTContext, SourceManager.

#include "clang/Tooling/CommonOptionsParser.h"  // Parses command-line into compilation database and source path list.

#include "llvm/Support/CommandLine.h"  // LLVM’s command-line parser (cl::opt, cl::OptionCategory).
#include "llvm/Support/raw_ostream.h"  // errs(), outs(): Fast, buffered output streams (like std::cout/

using namespace llvm;               // Bring LLVM utility classes (errs, outs, cl) into scope.
using namespace clang;              // Bring clang types (ASTContext, Decl, Expr, etc.) into scope.
using namespace clang::ast_matchers;  // Bring ASTMatchers functions (callExpr, functionDecl, etc.).
using namespace clang::tooling;     // Bring ClangTool, CommonOptionsParser into scope.

//===----------------------------------------------------------------------===//
// OptionCategory: Groups our tool’s CLI flags under "clang-buffer-tracer options".
// This allows users to filter help to only our tool’s options.
static cl::OptionCategory ToolCategory("clang-buffer-tracer options");

//===----------------------------------------------------------------------===//
// WriteVisitor: A RecursiveASTVisitor that searches for writes to a specific VarDecl
// (e.g., a local char buffer). It has two main Visit methods:
// 1) VisitCallExpr: catches function calls whose first argument is our buffer.
// 2) VisitBinaryOperator: catches assignments to our buffer variable.
class WriteVisitor : public RecursiveASTVisitor<WriteVisitor> {
public:
  // Var: pointer to the VarDecl we want to track (e.g., `char commandBuffer[100]`).
  // ASTContext: provides allocation, source-manager, type information, etc.
  WriteVisitor(const VarDecl *Var, ASTContext &Ctx)
    : Var(Var), Ctx(Ctx) {

       // Capture initializer literal if present (works for char[] or const char*):
   if (Var->hasInit()) {
        if (auto *SL = dyn_cast<clang::StringLiteral>(Var->getInit()->IgnoreImpCasts()))
            Fragments.push_back(SL->getString().str());
     }
  }

  // VisitCallExpr is invoked for every function call expression in the AST.
  bool VisitCallExpr(CallExpr *Call) {
    // getNumArgs(): number of arguments in the call, must be >=1 to check first arg.
    if (Call->getNumArgs() > 0) {
      // getArg(0): retrieve the first argument Expr*, IgnoreImpCasts removes implicit cast nodes.
      Expr *Arg0 = Call->getArg(0)->IgnoreImpCasts();
      // dyn_cast<DeclRefExpr>: checks if Arg0 is a reference to a named declaration (variable).
      if (auto *Ref = dyn_cast<DeclRefExpr>(Arg0)) {
        // If the referenced declaration equals our tracked VarDecl, it’s a write call (e.g., snprintf).
        if (Ref->getDecl() == Var) {
          // SourceManager: maps AST SourceLocations to file/line/column.
          auto &SM = Ctx.getSourceManager();
          // LangOptions: needed by Lexer to get correct tokenization rules.
          auto &LO = Ctx.getLangOpts();
          // getSpellingLineNumber: line number where this CallExpr starts.
          unsigned Line = SM.getSpellingLineNumber(Call->getBeginLoc());

          // DirectCallee(): returns the FunctionDecl being called (e.g., snprintf)
          llvm::outs()
            << "call to " << Call->getDirectCallee()->getNameAsString()
            << " at line " << Line << "\n";

          // Loop over remaining arguments (index 1..N-1) to print their source text.
          for (unsigned i = 1; i < Call->getNumArgs(); ++i) {
            Expr *A = Call->getArg(i)->IgnoreImpCasts();
            // CharSourceRange: a [begin,end] pair of SourceLocations for tokens.
            CharSourceRange R = CharSourceRange::getTokenRange(A->getSourceRange());
            // Lexer: extracts the exact source text between those locations.
            StringRef Txt = Lexer::getSourceText(R, SM, LO);
            llvm::outs()
              << "    arg[" << i << "]: " << Txt.str() << "\n";
          }
        }
      }
    }
    return true;  // return true to continue traversing other nodes
  }

  // VisitBinaryOperator is invoked for every binary operator (e.g., =, +=) in the AST.
  bool VisitBinaryOperator(BinaryOperator *BinOp) {
    // isAssignmentOp(): true for operators like =, +=, -=, etc.
    if (BinOp->isAssignmentOp()) {
      Expr *LHS = BinOp->getLHS()->IgnoreImpCasts();
      if (auto *Ref = dyn_cast<DeclRefExpr>(LHS)) {
        if (Ref->getDecl() == Var) {
          auto &SM = Ctx.getSourceManager();
          auto &LO = Ctx.getLangOpts();
          unsigned Line = SM.getSpellingLineNumber(BinOp->getBeginLoc());
          llvm::outs()
            << "assignment to buffer at line " << Line << "\n";

          Expr *RHS = BinOp->getRHS()->IgnoreImpCasts();
          CharSourceRange R = CharSourceRange::getTokenRange(RHS->getSourceRange());
          StringRef Txt = Lexer::getSourceText(R, SM, LO);
          llvm::outs()
            << "    rhs: " << Txt.str() << "\n";
        }
      }
    }
    return true;  // continue traversal
  }

  unsigned getFragmentCount() const {
    return Fragments.size();
  }

  const std::string &getFirstFragment() const {
    return Fragments.front();
  }

private:
  const VarDecl   *Var;
  ASTContext      &Ctx;

  // <— Declare Fragments here:
  std::vector<std::string> Fragments;

};

//===----------------------------------------------------------------------===//
// SystemCallHandler: Called back by ASTMatchFinder when it finds a match.
// We registered a matcher for calls to `system(buffer)` inside any function.
class SystemCallHandler : public MatchFinder::MatchCallback {
public:
  // Rewriter reference is unused here but part of the interface
  explicit SystemCallHandler(Rewriter &Rewrite) : Rewrite(Rewrite) {}

  // run(): invoked once per match; Result contains bound nodes.
void SystemCallHandler::run(const MatchFinder::MatchResult &Result) {
  const auto *Call = Result.Nodes.getNodeAs<CallExpr>("systemCall");
  const auto *Func = Result.Nodes.getNodeAs<FunctionDecl>("enclosingFunc");
  if (!Call || !Func || Call->getNumArgs() != 1) return;

  const Expr *Arg = Call->getArg(0)->IgnoreImpCasts();
  auto &SM = Result.Context->getSourceManager();
  auto &LO = Result.Context->getLangOpts();

  // 1) Direct literal: system("...")?
  if (auto *SL = dyn_cast<clang::StringLiteral>(Arg)) {
    llvm::outs()
      << "Found system() call with literal argument: '"
      << SL->getString() << "' in function '"
      << Func->getName() << "'\n";
    return;
  }

  // 2) Variable case: could be char[] or const char*
  if (auto *DR = dyn_cast<DeclRefExpr>(Arg)) {
    if (auto *VD = dyn_cast<VarDecl>(DR->getDecl())) {
      // Run WriteVisitor to collect initializer + any writes
      WriteVisitor Visitor(VD, *Result.Context);
      Visitor.TraverseStmt(Func->getBody());

      // If exactly one fragment (the initializer) and it was a literal,
      // then nothing ever mutated it—treat as literal.
      if (Visitor.getFragmentCount() == 1) {
        const std::string &lit = Visitor.getFirstFragment();
        llvm::outs()
          << "Found system() call with variable '"
          << VD->getName() << "' = '"
          << lit << "' in function '"
          << Func->getName() << "'\n";
        return;
      }

      // Otherwise fall into your full buffer‐tracing + execv suggestion:
      llvm::outs()
        << "Found system() call using buffer '"
        << VD->getName() << "' in function '"
        << Func->getName() << "'\n";

      // … your existing logic to trace writes, reconstructCommand(),
      //     and emit execv(…) …
      return;
    }
  }

  // 3) Fallback for anything else (complex expr)
  CharSourceRange Range = CharSourceRange::getTokenRange(Arg->getSourceRange());
  StringRef Txt = Lexer::getSourceText(Range, SM, LO);
  llvm::outs()
    << "Found system() call with complex argument: "
    << Txt.str() << " in function '"
    << Func->getName() << "'\n";
}



private:
  Rewriter &Rewrite;  // Provided for potential rewrites (unused here)
};

//===----------------------------------------------------------------------===//
// RewriteAction: Sets up the ASTConsumer and matchers for each source file.
class RewriteAction : public ASTFrontendAction {
public:
  // Called once per source file. Sets up matchers via an ASTConsumer.
  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
                                                 StringRef) override {
    // Initialize our Rewriter with the file’s SourceManager and lang options
    TheRewriter.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());

    // Define a matcher:
    //   callExpr(                  // any function call
    //     callee(functionDecl(hasName("system"))),  // named "system"
    //     hasAncestor(functionDecl().bind("enclosingFunc"))  // inside some function
    //   ).bind("systemCall")  // bind this callExpr to the id "systemCall"
    Matcher.addMatcher(
      callExpr(
        callee(functionDecl(hasName("system"))),
        hasAncestor(functionDecl().bind("enclosingFunc"))
      ).bind("systemCall"),
      &Handler  // our callback
    );

    // Return consumer that will run this matcher over the AST
    return Matcher.newASTConsumer();
  }

  // After parsing each file, we could output rewrite diffs here
  void EndSourceFileAction() override {}

private:
  Rewriter TheRewriter;                       // Manages sources and edits
  SystemCallHandler Handler{TheRewriter};     // Callback instance
  MatchFinder Matcher;                        // Orchestrates matching
};

//===----------------------------------------------------------------------===//
// main(): Entry point. Parses command-line args and runs our tool.
int main(int argc, const char **argv) {
  // Hide all clang::driver and llvm::cl options not in our category
  cl::HideUnrelatedOptions(ToolCategory);
  // Create a CommonOptionsParser: reads -p, -- etc. into a compilations database
  auto ExpectedParser = CommonOptionsParser::create(argc, argv, ToolCategory);
  if (!ExpectedParser) {
    // On error, print the error message and exit
    llvm::errs() << ExpectedParser.takeError();
    return 1;
  }

  // Build a ClangTool that will run our RewriteAction over each input file
  ClangTool Tool(ExpectedParser->getCompilations(),
                 ExpectedParser->getSourcePathList());
  // Execute the tool (runs front-end actions per file)
  return Tool.run(newFrontendActionFactory<RewriteAction>().get());
}
